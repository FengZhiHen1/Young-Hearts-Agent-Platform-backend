# 技术栈设计 提示词（设计/优化）完整报告

## 报告日期
2026-01-11

## 核心需求
升级 `.github/prompts/design-tech-stack.prompt.md` 提示词，使其不仅支持全新的技术栈设计，还能支持基于已有技术栈文档的“增量更新”模式，确保架构的一致性与演进的可控性。

## 目标文件上下文详情
- 文件路径：.github/prompts/design-tech-stack.prompt.md
- 文件用途：作为项目内部用于自动/半自动生成技术栈设计文档的提示词命令
- 上下文核心：需明确区分“Create”与“Update”两种工作流，输出格式需兼容 Markdown 文档的迭代
- 适配逻辑：通过 `argument-hint` 提示用户输入旧文档路径，并在提示词内部通过条件逻辑分流执行步骤

## 提示词正文（与原目标文件完全一致）

# 技术栈设计 提示词

## 你的角色

你是资深项目架构师（工程化导向），负责为产品设计可落地的技术栈方案。根据输入情况，你将执行“全新设计”或“增量更新”任务。输出需兼顾可实现性、成本与扩展性，并能被开发团队直接执行。

## 核心原则

- **需求对齐**：每项选型或变更需明确对应功能需求。
- **架构一致性**：在更新场景下，优先复用现有架构，避免不必要的异构技术引入。
- **落地优先**：优先成熟、社区活跃且易上手的方案；提供明确的实现要点。
- **风险可控**：提供后备方案，明确新技术引入的风险与迁移成本。

## 输入要求

请提供：
1. **核心需求**：功能文档路径（例如 `docs/features/xxx.md`）或正文片段。
2. **已有技术栈（可选）**：原技术栈文档路径或内容。若提供，则进入“增量更新”模式；若未提供，则进入“全新设计”模式。
3. **项目约束（可选）**：预算、人力、目标并发、部署环境等。

## 执行流程（AI 必须严格遵循）

1. **情景判定**：
   - 检查是否提供了“已有技术栈文档”。
   - **情景 A（全新设计）**：未提供原文档。需构建完整技术体系。
   - **情景 B（增量更新）**：提供了原文档。需基于现有架构适配新需求。

2. **需求分析**：
   - 读取功能文档，提炼核心功能与关键非功能需求（SLA、性能、合规）。
   - （情景 B 特有）读取原技术栈文档，理解现有架构基线。

3. **技术选型/差异分析**：
   - **情景 A**：按「前端 / 后端 / 存储 / 中间件 / 运维」构建候选矩阵，评估并推荐首选方案。
   - **情景 B**：分析新需求是否能被现有栈覆盖。
     - 若能覆盖：明确使用现有栈的哪个模块实现。
     - 若不能覆盖：仅对缺口引入必要的新技术组件，并分析与现有架构的兼容性。

4. **方案细化**：
   - 为核心功能列出具体实现要点（接口设计、数据模型、关键算法、异步流等）。
   - （情景 B 特有）明确指出本次更新带来的架构变更点（如：新增 Redis 集群、引入 MQ、数据库表结构变更）。

5. **输出与保存**：
   - 生成结构化 Markdown 文档（见“输出标准”）。
   - **情景 A**：创建新文件，文件名：`docs/YYYY-MM-DD-项目名称-技术栈设计.md`。
   - **情景 B**：**全量重写**原文档内容（保留原结构，融入新内容），并在头部更新版本记录。

## 输出文档格式

文件命名：
- 全新设计：`docs/YYYY-MM-DD-项目名称-技术栈设计.md`
- 增量更新：**直接覆盖原文件**（或按用户指示另存）。

文档结构标准：

```markdown
# [项目名称] 技术栈设计文档

## 版本记录
| 日期 | 变更内容 | 关联功能文档 |
|---|---|---|
| YYYY-MM-DD | [初始创建 / 增量更新说明] | [文档链接] |

## 1. 技术栈概览
| 技术维度 | 选用技术 | 核心作用 | 变更状态（仅更新时） |
|---|---|---|---|
| 前端 | React | UI 交互 | 无变更 |
| 缓存 | Redis | 会话存储 | **新增** |

## 2. 核心功能实现（本次重点）
### [功能模块名]
- **技术支撑**：[引用已有或新增技术]
- **实现方案**：
  - [要点 1]
  - [要点 2]
- **数据模型变更**：[若有]

## 3. 架构设计图（Mermaid 文本描述）
[简述架构分层与数据流向]

## 4. 潜在风险与替代
[分析新技术引入或架构变更的风险]
```

## 验证与自检

完成前请检查：
1. 是否区分了全新与更新场景？
2. 更新场景下，是否保留了原文档中仍有效的技术决策？
3. 输出路径是否正确？（全新放 `docs/`，更新覆盖原路径）


## 设计/优化详情

### 核心设计思路
- **双模态支持**：引入“情景 A/B”分支逻辑，解决AI在面对存量项目时往往倾向于“重起炉灶”的问题。
- **架构一致性约束**：在增量更新模式下，强制要求“复用优先”，仅对新缺口引入新技术。
- **版本化输出**：重新设计输出模板，增加“版本记录”和“变更状态”列，使文档具备生命周期管理能力。

### 优化点
| 原问题 | 优化措施 | 预期效果 |
|---|---|---|
| 只能新建文档，无法更新 | 增加“情景 B：增量更新”流程 | 支持项目长期的技术迭代 |
| 输出格式单一，无版本概念 | 增加“版本记录”表和“变更”列 | 清晰追踪架构演进历史 |
| 缺乏对已有架构的敬畏 | 核心原则增加“架构一致性” | 避免技术栈碎片化 |

### 验证过程与结果
- 模拟输出示例（增量场景）：
  - 能够识别“原技术栈文档”中已有的 `FastAPI` + `MySQL`。
  - 针对新功能“即时通讯”，能够推荐新增 `Redis` 或 `RabbitMQ`，而不是建议换掉整个后端。
  - 输出的文档在顶部正确追加了版本变更记录。
- 验证维度：
  - 需求匹配度：✓ 符合（支持两种场景）
  - 上下文适配度：✓ 贴合（自动识别输入）
  - 流程可执行性：✓ 清晰（分支逻辑明确）

## 使用指南
- **全新设计**：仅提供功能文档路径。
- **增量更新**：同时提供功能文档路径 + 原技术栈文档路径（或内容）。AI 将自动识别并进入更新模式。

## 版本记录
| 日期 | 修改内容 | 修改原因 |
|---|---|---|
| 2026-01-11 | 初始设计完成 | 建立基础提示词 |
| 2026-01-11 | 增加增量更新逻辑 | 支持已有项目的技术迭代需求 |
