# 后端用户身份控制 研究报告

## 版本记录

| 日期 | 版本 | 修改内容 | 修改原因 |
|---|---|---|---|
| 2026-01-14 | v1.0 | 初始研究报告 | 参考前端 context 方案，梳理后端现状与改进建议 |
| 2026-01-14 | v2.0 | 全面重构为 context+HttpOnly Cookie 方案，重塑 User 结构 | 对齐前端统一身份管理与安全需求 |
| 2026-01-14 | v3.0 | 彻底重构，补充多端 context 统一、角色权限映射、会话策略等 | 明确对齐功能文档与多端适配需求 |
| 2026-01-14 | v4.0 | 全面重构，严格对齐《数据模型与 API 设计》文档，重写所有实现分析与建议 | 以权威数据模型和接口为唯一依据 |
| 2026-01-14 | v4.1 | 会话唯一标志调整为 SessionID，统一相关表述与代码片段 | 采用更安全、可控的会话机制 |

## 研究问题

如何基于《心青年智能体平台-数据模型与 API 设计》文档，构建安全、可扩展、支持多角色与多端一致，且以 SessionID 作为唯一会话标志的后端用户身份管理与权限控制体系？

## 发现摘要

- 用户身份体系以 User/VolunteerProfile/ExpertProfile 三表为核心，roles 字段为英文数组，权限矩阵与 API 设计严格一致。
- 会话机制统一采用 SessionID 作为唯一会话标志，Web 端用 HttpOnly Cookie，App/API 端用 Header，所有接口鉴权方式与 API 设计表格完全对齐。
- context 注入、权限校验、Mock 策略、安全措施等均以 API 设计为唯一标准，所有字段、接口、角色、权限均有出处。
- 权限校验与资源隔离严格参照 API 权限列，支持资源/操作级别的灵活扩展。

## 相关文件清单

|文件路径|作用说明|关键行号|
|---|---|---|
|app/models/user.py|User/VolunteerProfile/ExpertProfile ORM模型|L1-L80|
|app/schemas/user.py|Pydantic 用户模型，字段对齐 API 设计|L1-L60|
|app/api/v1/routes/auth.py|登录/登出/注册/当前用户接口|L1-L60|
|app/api/v1/routes/users.py|用户档案、角色申请、用户列表等|L1-L80|
|app/services/auth.py|会话创建、校验、context 注入中间件|L1-L80|

## 当前实现分析

### 1. 用户数据模型与角色体系

- 用户主表 User 字段严格对齐 API 设计：id, username, email, password_hash, nickname, avatar, roles (Array<String>), status, created_at。
- 志愿者/专家扩展表 VolunteerProfile/ExpertProfile 通过 user_id 关联，所有扩展字段与 API 设计一致。
- roles 字段仅存英文：['family', 'volunteer', 'expert', 'admin', 'maintainer']，权限矩阵见 API 设计表格。

### 2. 会话机制与 context 注入

- 登录接口 POST /api/auth/login，成功后生成唯一 SessionID。
- Web 端通过 Set-Cookie 设置 HttpOnly、SameSite、Secure 的 session Cookie，App/API 端通过 Header（如 X-Session-ID）传递 SessionID。
- 所有需鉴权接口（除 /public, /auth/login, /auth/register）均需校验 SessionID，接口鉴权方式与 API 设计一致。
- context 注入中间件自动识别 Cookie/Header，解析 SessionID 并获取用户信息，注入 request context，业务层通过 current_user 获取。

### 3. 权限控制与资源隔离

- 权限校验严格基于 roles 字段英文值，所有接口权限要求见 API 设计表格（如 /api/admin/users 仅 admin 可用）。
- 支持资源/操作级权限扩展，典型装饰器实现：
```python
def require_roles(roles: list):
    def decorator(func):
        def wrapper(*args, **kwargs):
            user = get_current_user_from_context()
            if not user or not set(user.roles).intersection(set(roles)):
                raise HTTPException(status_code=403, detail="Permission denied")
            return func(*args, **kwargs)
        return wrapper
    return decorator
```

### 4. 多端适配与接口一致性

- 会话生成、校验、过期策略完全统一，均以 SessionID 为唯一标志，Web 端用 Cookie，App/API 端用 Header，context 注入屏蔽多端差异。
- Mock 策略建议：前端开发期间用 Mock.js 拦截接口，字段名与 API 设计严格一致。

### 5. 安全性与边缘场景

- Web 端需开启 HttpOnly、SameSite、Secure，防止 CSRF/Cookie 泄露，SessionID 不可被 JS 访问。
- 敏感字段（如 phone, real_name）仅 admin 可见，接口需脱敏或剔除。
- 会话失效与登出需及时清理 context，防止伪登录，SessionID 需及时失效。

### 6. 关键代码片段

#### 用户模型（对齐 API 设计）
```python
from datetime import datetime
from sqlalchemy.orm import Mapped, mapped_column
from sqlalchemy import Integer, String, JSON, DateTime

class User(Base):
    __tablename__ = "users"
    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    username: Mapped[str] = mapped_column(String, unique=True)
    email: Mapped[str] = mapped_column(String, unique=True)
    password_hash: Mapped[str] = mapped_column(String)
    nickname: Mapped[str] = mapped_column(String)
    avatar: Mapped[str] = mapped_column(String)
    roles: Mapped[list] = mapped_column(JSON)  # 例：["volunteer", "admin"]
    status: Mapped[str] = mapped_column(String)
    created_at: Mapped[datetime] = mapped_column(DateTime)
```

#### 登录接口（SessionID 方案，多端适配）
```python
@router.post("/api/auth/login")
def login(form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db)):
    user = authenticate_user(db, form_data.username, form_data.password)
    if not user:
        raise HTTPException(status_code=401, detail="Incorrect username or password")
    session_id = create_session_id(user)  # 生成唯一 SessionID
    response = JSONResponse(content={"msg": "login success"})
    # Web 端
    response.set_cookie(
        key="session", value=session_id, httponly=True, samesite="lax", secure=True
    )
    # App/API 端由前端存储 session_id 并在 Header（如 X-Session-ID）传递
    return response
```

#### context 注入中间件（多端统一，SessionID 方案）
```python
def get_current_user_from_context(request: Request, db: Session = Depends(get_db)):
    session_id = request.cookies.get("session") or request.headers.get("X-Session-ID")
    user = get_user_by_session_id(db, session_id)
    if not user:
        raise HTTPException(status_code=401, detail="Not authenticated")
    return user
```

#### 权限校验装饰器
```python
# 见上文 require_roles 示例
```

## 架构洞察

- 以 API 设计为唯一标准，所有身份、权限、接口、字段均有出处，便于前后端协作和多端一致。
- context 注入与权限校验完全解耦端类型，后续扩展新端无需重写核心逻辑。
- roles 字段英文存储，权限矩阵灵活扩展，支持国际化和多语言。

## 潜在风险和边缘情况

- CSRF 风险：Web 端需配合 SameSite、CSRF Token 等防护措施。
- Cookie 泄露风险：需开启 Secure、HttpOnly，避免跨域。
- 兼容性：部分 API 客户端需适配 Cookie/Token 认证。
- 敏感字段暴露风险：接口需严格按角色脱敏。
- 会话失效与登出需及时清理 context，防止“伪登录”状态。

## 开放问题

- 角色权限、接口、字段如有调整，需同步更新 API 设计文档。
- 多端 context 注入与会话管理已统一，所有端权限校验逻辑完全复用，SessionID 作为唯一会话凭证。

## 参考资料

- [“心青年”智能体平台-数据模型与 API 设计.md](../../“心青年”智能体平台-数据模型与 API 设计.md)
- [FastAPI Cookie 安全实践](https://fastapi.tiangolo.com/advanced/security/http-cookies/)
- [OWASP Session Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html)
- [前端 context 研究报告](../00-来自前端react项目/05-用户身份控制/2026-01-13_通过context实现用户身份控制_研究报告.md)
