# 用户管理 实现计划

## 计划日期

2025-12-28

## 关联研究

`docs/tasks/02-用户管理/2025-12-28_用户管理_研究报告.md`

## 功能概述

实现用户管理模块，包含用户注册（含密码哈希）、登录（OAuth2 password flow + JWT）、用户信息的读取/更新/删除（基于权限），以及基础的鉴权依赖（`get_current_user`）供受保护路由复用。

## 技术方案摘要

- 数据层：同步 SQLAlchemy ORM（与现有 `app/db/session.py` 保持一致），新增 `User` 模型并在 `app/models/__init__.py` 中导入以注册 metadata。
 - 数据层：同步 SQLAlchemy ORM（与现有 `app/db/session.py` 保持一致），数据库选型：MySQL（使用 SQLAlchemy 的 MySQL 驱动 `PyMySQL`），新增 `User` 模型并在 `app/models/__init__.py` 中导入以注册 metadata。
- 密码哈希：使用 `passlib[bcrypt]`（可选 `argon2`，待确认）。
- Token：使用 `python-jose` 进行 JWT 编码/解码，遵循 OAuth2 Password Flow（`/auth/token` 返回 `access_token`，可后续扩展 `refresh_token`）。
- 路由：新增 `app/api/v1/routes/users.py`（用户管理）和 `app/api/v1/routes/auth.py`（token），并在 `app/main.py` 注册。
- 服务/业务层：在 `app/services/` 下添加 `auth.py` 与 `user_service.py`，把 DB 访问与验证逻辑封装，便于测试。
 - 密码哈希：使用 `passlib[bcrypt]`（已确认采用 `bcrypt`）。
 - Token：使用 `python-jose` 进行 JWT 编码/解码，遵循 OAuth2 Password Flow。仅颁发短期 `access_token`（本次不实现 `refresh_token`）。
 - 路由：新增 `app/api/v1/routes/users.py`（用户管理）和 `app/api/v1/routes/auth.py`（token），并在 `app/main.py` 注册。
 - 服务/业务层：在 `app/services/` 下添加 `auth.py` 与 `user_service.py`，把 DB 访问与验证逻辑封装，便于测试。

注：本计划明确使用 MySQL 作为关系型数据库。推荐使用 `PyMySQL` 作为 DBAPI（连接字符串示例：`mysql+pymysql://user:password@host:3306/dbname`）。请在生产/开发环境中通过环境变量设置 `DATABASE_URL`，并确保 MySQL 实例已创建相应数据库与用户权限。

---

## 已确认实现细节

- 鉴权方案：仅短期 JWT `access_token`（不实现 `refresh_token`）。
- 邮箱验证 / 找回密码：暂不实现（将来可作为扩展）。
- 第三方登录（微信/统一认证）：不需要。
- 密码哈希算法：使用 `bcrypt`（via `passlib[bcrypt]`）。

---

## Phase 1: 数据层与模型 (准备阶段)

### 目标

- 新增 `User` ORM 模型并注册到 metadata，确保 `init_db()` 可创建 `users` 表。
- 新增 Pydantic schema 用于请求/响应。

### 修改文件清单

|文件路径|修改类型|说明|
|---|---|---|
|`app/models/user.py`|新建|新增 `User` ORM 模型|
|`app/models/__init__.py`|修改|导入 `User` 以注册 metadata|
|`app/schemas/user.py`|新建|Pydantic 模型：`UserCreate`/`UserOut`/`UserUpdate`|
|`requirements.txt`|修改|添加 `passlib[bcrypt]`、`python-jose[cryptography]`（建议）|

建议在 `requirements.txt` 中同时添加：

- `PyMySQL`（用于 SQLAlchemy 的 MySQL 连接）

例如：

```
passlib[bcrypt]
python-jose[cryptography]
PyMySQL
```

### 具体变更

#### 1. 新增 `User` 模型

文件：`app/models/user.py`

修改后（示例）：

```python
from sqlalchemy import Column, BigInteger, String, Boolean, DateTime
from sqlalchemy.sql import func
from app.models import Base

class User(Base):
    __tablename__ = "users"
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    username = Column(String(150), nullable=False, unique=True)
    email = Column(String(320), unique=True)
    password_hash = Column(String(255), nullable=False)
    full_name = Column(String(255))
    is_active = Column(Boolean, default=True)
    is_superuser = Column(Boolean, default=False)
    created_at = Column(DateTime(timezone=False), server_default=func.now())
    updated_at = Column(DateTime(timezone=False), server_default=func.now(), onupdate=func.now())
```

（注：长度与字段可根据 `docs/tasks/01-数据库配置` 的建议表结构调整）

数据库相关注意事项：

- 使用 MySQL 时建议设置 `utf8mb4` 字符集以支持完整 Unicode（包括 emoji）。
- SQLAlchemy 连接字符串示例：`mysql+pymysql://<user>:<password>@<host>:<port>/<dbname>?charset=utf8mb4`
- 在本地开发可使用 Docker Compose 启动 MySQL，或使用已有的 MySQL 实例。确保 `app/core/config.py` 通过 `DATABASE_URL` 环境变量读取连接字符串。

#### 2. 在 `app/models/__init__.py` 导入注册模型

文件：`app/models/__init__.py`

修改后（示例）：

```python
from sqlalchemy.orm import declarative_base

Base = declarative_base()

# 导入所有模型以便 metadata 注册
from app.models import user  # noqa: F401
```

### 成功标准

自动验证：

- [ ] `python -c "from app.db.session import init_db; init_db()"` 能执行且数据库中创建 `users` 表（或运行现有初始化流程无错误）
- [ ] 使用 MySQL：确认 `DATABASE_URL` 指向一个可连接的 MySQL 实例，且 `init_db()` 能在该 MySQL 中创建 `users` 表（或运行现有初始化流程无错误）。
- [ ] `pytest tests/`（包含新增的模型测试）通过

手动验证：

- [ ] 查看数据库表结构，字段与约束符合设计

---

## Phase 2: 鉴权与 API（核心实现）

### 目标

- 实现注册、登录（token 颁发）、获取当前用户、更新当前用户接口。
- 提供 `get_current_user` 依赖以便其它路由复用。

### 修改文件清单

|文件路径|修改类型|说明|
|---|---|---|
|`app/services/auth.py`|新建|认证/Token 生成/校验逻辑|
|`app/services/user_service.py`|新建|用户 CRUD 与验证逻辑|
|`app/schemas/user.py`|修改|增加 `Token`/`TokenData` schema|
|`app/api/v1/routes/auth.py`|新建|`/auth/token` 实现 OAuth2 token endpoint|
|`app/api/v1/routes/users.py`|新建|`/users/register`, `/users/me`, `/users/me` (PUT/DELETE) 等|
|`app/main.py`|修改|注册新路由（如果尚未自动发现）|

### 具体变更

#### 1. `auth` 服务示例（核心逻辑）

文件：`app/services/auth.py`

关键职责：

- 密码散列/校验（使用 `passlib.context.CryptContext`）
- JWT 编/解码（使用 `jose.jwt`），配置 `SECRET_KEY`、`ALGORITHM`、`ACCESS_TOKEN_EXPIRE_MINUTES`
- `create_access_token`、`verify_password`、`authenticate_user`

示例代码片段：

```python
from passlib.context import CryptContext
from datetime import datetime, timedelta
from jose import jwt
from app.core.config import settings

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password):
    return pwd_context.hash(password)

def create_access_token(data: dict, expires_delta: timedelta | None = None):
    to_encode = data.copy()
    expire = datetime.utcnow() + (expires_delta or timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt
```

#### 2. 路由示例：`/users/register`

文件：`app/api/v1/routes/users.py`

```python
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from app.schemas.user import UserCreate, UserOut
from app.db.session import get_db
from app.services.user_service import create_user

router = APIRouter(prefix="/users", tags=["users"])

@router.post("/register", response_model=UserOut, status_code=status.HTTP_201_CREATED)
def register_user(payload: UserCreate, db: Session = Depends(get_db)):
    try:
        user = create_user(db, payload)
        return user
    except IntegrityError:
        raise HTTPException(status_code=409, detail="用户名或邮箱已存在")
```

### 成功标准

自动验证：

- [ ] 注册流程能创建用户并在 DB 中存储 `password_hash`（不存明文）
- [ ] 使用 `/auth/token` 正确返回 `access_token` 并可被 `get_current_user` 验证
- [ ] 相关路由的单元测试通过（`pytest tests/test_users.py`）

手动验证：

- [ ] 使用 `curl` 或 Postman 测试：注册 -> 登录 -> 使用 `Authorization: Bearer <token>` 访问 `/users/me`

---

## Phase 3: 测试、文档与部署（完善）

### 目标

- 完整的单元测试和集成测试覆盖关键路径（注册/登录/鉴权/更新/异常情况）。
- 更新 `requirements.txt`、README，并在 docs 中记录使用说明。

### 修改文件清单

|文件路径|修改类型|说明|
|---|---|---|
|`tests/test_users.py`|新建|用户管理相关测试|
|`requirements.txt`|修改|添加运行与测试所需依赖|
|`README.md`|修改|添加运行示例与 API 使用说明|

### 成功标准

- [ ] `pytest tests/test_users.py` 全部通过
- [ ] CI（若存在）在拉取请求时可以运行这些测试

---

## 风险和缓解措施

|风险|可能性|影响|缓解措施|
|---|---|---|---|
|密码处理不当|中|高|必须使用 `passlib`/bcrypt 或 argon2；避免自研加密；审查存储字段长度|
|唯一性冲突（并发注册）|中|中|在 DB 层设置唯一索引，并捕获 `IntegrityError` 返回 409；必要时使用重试或去重逻辑|
|Token 泄露或长期有效|中|高|合理设置 `ACCESS_TOKEN` 有效期；如需长期登录，设计 `refresh_token` 策略并支持撤销|

## 回滚方案

- 通过 Git 回退最近的变更分支或 commit。
- 如果数据库迁移导致问题，使用备份或者删除/重建表（仅在开发环境），生产环境需提前备份并提供回滚脚本。

## 后续优化（非本次范围）

- 引入 refresh token + token 存储/撤销表以支持登出与强制下线。
- 邮箱验证与找回密码流程。
- 第三方登录（OAuth）适配（微信/学校统一认证）。
- 考虑切换到异步 DB 驱动以支持高并发场景。

## 迭代提示

每次迭代后，建议向用户确认：

1. 阶段划分是否合理？
2. 有没有遗漏的变更点或合规要求（如日志/审计）？
3. 成功标准是否具体并可验证？
4. 需要优先实现的额外功能（refresh token / 邮箱验证 / 第三方登录）？

## 完成后

- 计划文档保存路径：`docs/tasks/02-用户管理/2025-12-28-用户管理.md`
- 核心阶段概述：Phase 1 数据层 -> Phase 2 鉴权与 API -> Phase 3 测试与文档
- 提醒：本会话中上下文占用较多（若超 60% 请执行 `/clear` 清理）
- 下一步：如果你确认计划，我可以开始 `implement_plan`，先从 Phase 1（添加模型与 schema）实现并运行相关测试。