# 用户管理（注册 / 登录 / 信息管理）研究报告

## 研究日期

2025-12-28

## 研究问题

如何在当前代码库中实现用户管理（包括注册、登录、用户信息的增删改查与鉴权）？

## 发现摘要

- 代码库目前已配置同步 SQLAlchemy 会话（`app/db/session.py`），但尚未在 `app/models/` 中找到已实现的 `User` ORM 模型（见 `app/db/session.py` L1-L6, L9-L14）。
- 项目设计文档建议使用 JWT（OAuth2 password flow）作为鉴权方式，并在 API 设计中预留 `/users/register` 等接口（见 `0-prompts/settings/2-architect.md` 中用户接口片段）。
- 在文档 `docs/tasks/01-数据库配置/2025-12-28_为项目配置MySQL数据库.md` 中已有推荐的 `users` 表结构（包含 `username`, `password_hash`, `email`, `is_superuser` 等字段），可以直接复用为 ORM 设计。

## 相关文件清单

|文件路径|作用说明|关键行号|
|---|---|---:|
|`app/db/session.py`|SQLAlchemy engine 与 `SessionLocal`，`get_db()` 依赖注入与 `init_db()`|L1-L6, L9-L14|
|`0-prompts/settings/2-architect.md`|项目架构/接口设计建议（包含 `/users/register` 请求示例）|约 L200-L226|
|`docs/tasks/01-数据库配置/2025-12-28_为项目配置MySQL数据库.md`|已有用户表设计与示例 ORM 代码，可复用为 `User` 模型参考|多个段落（users 表模型示例）|
|`app/main.py`|项目启动时会调用 `init_db()`（确保 models 被导入以创建表）|见 `app/main.py` 对 `init_db()` 的导入调用|

## 当前实现分析

1) 数据层
- 项目使用同步 SQLAlchemy：`engine = create_engine(settings.DB_URL, future=True)`，并用 `SessionLocal = sessionmaker(...)` 提供同步会话（`app/db/session.py`）。
- `init_db()` 会调用 `Base.metadata.create_all(bind=engine)`，但当前 `app/models` 中未见确实的 `User` 模型实现，因此需新增模型文件并在 `app/models/__init__.py` 导入以注册 metadata。

2) 鉴权与接口设计
- 设计文档倾向于使用 JWT（FastAPI + OAuth2 Password Flow），API 使用 Bearer Token（见架构设计文档）。
- 接口建议包含：`POST /users/register`（注册）、`POST /auth/token`（登录 / 获取 token — OAuth2 token endpoint）、`GET /users/me`（获取当前用户信息）、`PUT /users/me`（更新用户信息）、管理员专用的用户管理接口（列举/删除/修改等）。

3) 业务逻辑（建议）
- 注册：接收 `username`/`password`/`email`，校验唯一性，对密码进行安全哈希（推荐 `bcrypt` 或 `passlib` 的 `bcrypt`/`argon2`），保存 `password_hash`。
- 登录：采用 OAuth2 password flow，校验用户名/密码后签发 JWT（短期 access token + 可选 refresh token），将用户 id 与角色放入 token claims。
- 用户信息管理：受保护接口，依赖 `get_current_user`（通过 token 验证并从 DB 加载用户）来完成读取与更新操作。

## 核心流程（文字描述）

客户端 -> POST `/users/register` -> 后端：校验/哈希密码 -> 写 `users` 表 -> 返回 201

客户端 -> POST `/auth/token` (username+password) -> 后端：校验凭证 -> 返回 JWT

受保护请求 -> 前端在 Authorization: Bearer <token> -> 后端依赖 `get_current_user` 解 token -> 从 DB 加载用户并验证权限 -> 返回资源

## 关键代码片段（建议实现）

- `app/models/user.py`（示例 ORM）

```python
from sqlalchemy import Column, BigInteger, String, Boolean, DateTime
from sqlalchemy.sql import func
from app.models import Base

class User(Base):
    __tablename__ = "users"
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    username = Column(String(150), nullable=False, unique=True)
    email = Column(String(320), unique=True)
    password_hash = Column(String(255), nullable=False)
    full_name = Column(String(255))
    is_active = Column(Boolean, default=True)
    is_superuser = Column(Boolean, default=False)
    created_at = Column(DateTime(timezone=False), server_default=func.now())
    updated_at = Column(DateTime(timezone=False), server_default=func.now(), onupdate=func.now())
```

- 鉴权工具建议：使用 `python-jose` 进行 JWT 编解码，使用 `passlib[bcrypt]` 或 `bcrypt` 做密码哈希。

## 架构洞察

- 现有项目结构已为传统 REST + SQLAlchemy 同步模式准备好：实现用户管理可按文档直接补充模型与路由，改动范围小。
- 若未来需要高并发/实时（WebSocket）场景，需评估是否迁移到 async SQLAlchemy 与异步 MySQL 驱动。
- 项目中已有 `VECTOR_STORE` 与知识库相关模块，用户表应设计轻量（不存向量），并用 `vector_id` 做映射或在向量服务中管理。

## 潜在风险和边缘情况

- 密码处理：不要存明文密码，必须使用强哈希；考虑密码重置流程与邮箱验证。
- Token 失效/刷新：需要设计 refresh token 或合理的 access token 生命周期并支持撤销（登出），否则安全风险较高。
- 用户名/邮箱唯一性竞争：注册并发时需在 DB 层保证唯一约束并处理冲突（捕获 IntegrityError 并返回 409）。

## 开放问题（需要用户确认）

1. 期望的鉴权方案：仅 JWT access token（短期）即可，是否需要 refresh token？
2. 是否需要邮箱验证 / 找回密码功能？
3. 是否需要第三方登录（如微信/学校统一认证）？
4. 希望使用哪种密码哈希算法（`bcrypt` / `argon2`）与具体驱动（`PyMySQL` / `mysqlclient` / `asyncmy`）？

## 参考资料

- `app/db/session.py`（项目 SQLAlchemy 配置）
- `0-prompts/settings/2-architect.md`（接口示例：`/users/register`）
- `docs/tasks/01-数据库配置/2025-12-28_为项目配置MySQL数据库.md`（users 表设计示例）

## 完成后

1. 文档已保存路径：`docs/tasks/02-用户管理/2025-12-28_用户管理_研究报告.md`
2. 研究核心发现摘要：项目已具备同步 SQLAlchemy 基础与接口设计倾向（JWT），缺少具体 `User` 模型与认证路由；可沿用已存在的数据库设计文档快速实现注册/登录/用户管理。
3. 需要您确认的问题：见“开放问题”部分（4 项）。
4. 关于上下文占用提醒：如果你在本会话里累积了大量上下文（>60%），建议执行 `/clear` 来清理会话历史以避免上下文干扰。
